<?php


namespace iikoExchangeBundle\Library\base\Connection;


use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Uri;
use iikoExchangeBundle\Contract\Auth\TokenAuthDataInterface;
use iikoExchangeBundle\Library\base\Config\Types\PasswordConfigItem;
use iikoExchangeBundle\Library\base\Config\Types\StringConfigItem;
use Psr\Http\Message\RequestInterface;

abstract class AbstractDigestConnection extends AbstractConnection
{
	const TOKEN_TYPE_QUERY = 'token_in_query';
	const TOKEN_TYPE_HEADER = 'token_in_header';

	protected string $tokenName = 'key';
	protected string $tokenType = self::TOKEN_TYPE_QUERY;

	/** @var TokenAuthDataInterface */
	protected TokenAuthDataInterface $authData;

	/**
	 * @return TokenAuthData
	 */
	protected function getAuthData()
	{
		$this->authData ??= new TokenAuthData(json_decode(parent::getAuthData())); // TODO: Change the autogenerated stub
		return $this->authData;
	}

	protected function pushAddAuthDataHandler(HandlerStack $handlerStack)
	{
		if (empty($this->getAuthData()) || $this->getAuthData()->getToken() === null)
		{
			$this->login();
		}

		$handlerStack->push(Middleware::mapRequest(function (RequestInterface $request)
		{
			if ($this->tokenType === self::TOKEN_TYPE_QUERY)
			{
				$request = $request->withUri(Uri::withQueryValue($request->getUri(), $this->tokenName, $this->getAuthData()->getToken()));
			}
			if ($this->tokenType === self::TOKEN_TYPE_HEADER)
			{
				$request = $request->withHeader($this->tokenName, $this->getAuthData()->getToken());
			}
			return $request;

		}));
	}

	public function createConfig()  : array
	{
		return parent::createConfig() + ['user_name' => new StringConfigItem(), 'password' => new PasswordConfigItem()];
	}
}